
buttonHoverColors = {
  red    = { 1.0, 0.302, 0.302, 0.8 },
  orange = { 1.0, 0.549, 0.333, 0.8 },
  blue   = { 0.392, 0.667, 1.0, 0.8 },
  green  = { 0.431, 0.803, 0.412, 0.8 }
}

buttonBaseColors = {
  red    = { 219/255, 26/255, 24/255 },
  orange = { 244/255, 100/255, 29/255 },
  blue   = { 31/255, 136/255, 255/255 },
  green  = { 49/255, 179/255, 43/255 },
}

locs = {
  red = {
    confirmSkill = { -68.22, 1.34, -33.75 },
    confirmRace  = { -63.22, 1.14, -33.75 },
    confirmClass = { -46.68, 1.14, -33.75 },
  },
  orange = {
    confirmSkill = { -32.55, 1.34, -33.75 },
    confirmRace  = { -27.51, 1.14, -33.75 },
    confirmClass = { -10.99, 1.14, -33.75 },
  },
  blue = {
    confirmSkill = { 3.86, 1.34, -33.75 },
    confirmRace  = { 8.85, 1.14, -33.75 },
    confirmClass = { 25.36, 1.14, -33.75 },
  },
  green = {
    confirmSkill = { 39.46, 1.34, -33.75 },
    confirmRace  = { 44.49, 1.14, -33.75 },
    confirmClass = { 61.00, 1.14, -33.75 },
  },
}

skillButtons = { red = {}, orange = {}, blue = {}, green = {} }


function getObjectsByTag(tag, color)
  local objs = {}
  for _, obj in ipairs(getObjects()) do
    if obj.hasTag(tag) and (not color or obj.hasTag("player_" .. color)) then
      table.insert(objs, obj)
    end
  end
  return objs
end


function initSkillButtons()
  local playerColors = { "red", "orange", "blue", "green" }
  for _, playerColor in ipairs(playerColors) do
    local skillObjs = getObjectsByTag("btn_skill_selection", playerColor)
    skillButtons[playerColor] = {}
    for _, obj in ipairs(skillObjs) do
      local skill = obj.getName()
      skillButtons[playerColor][skill] = obj.getGUID()
      local state = obj.getGMNotes()
      if not obj.hasTag('banner') and skill ~= "Confirm" then
        if state == "enabled" then
          createSkillButton(obj, skill, true, playerColor)
        else
          obj.setGMNotes("disabled")
          createSkillButton(obj, skill, false, playerColor)
        end
      end
    end
  end
end


function createSkillButton(obj, skill, enabled, playerColor)
  local hoverColor = buttonHoverColors[playerColor] or { 1, 1, 1, 0 }
  obj.clearButtons()
  if enabled then
    obj.createButton({
      label          = "",
      click_function = "disableSkillToken",
      function_owner = self,
      position       = { 0, 0.11, 0 },
      height         = 1300,
      width          = 1300,
      font_size      = 1500,
      scale          = { 1, 1, 1 },
      color          = hoverColor,
      tooltip        = "De-Select Skill: " .. skill
    })
    obj.highlightOn((playerColor:gsub("^%l", string.upper)))
  else
    obj.createButton({
      label          = "",
      click_function = "enableSkillToken",
      function_owner = self,
      position       = { 0, 0.11, 0 },
      height         = 1300,
      width          = 1300,
      font_size      = 1100,
      scale          = { 1, 1, 1 },
      font_color     = { 1, 1, 1 },
      color          = { 0, 0, 0, 0 },
      hoverColor    = hoverColor,
      tooltip        = "Select Skill: "..skill
    })
    obj.highlightOff()
  end
end


function createSkillConfirmButton(obj, color)
  local func = "confirmSkillToken" .. color
  if not self.getVar(func) then
    self.setVar(func, function(o, playerColor, altClick) confirmSkillToken(o, playerColor, altClick, color) end)
  end
  obj.clearButtons()
  obj.createButton({
    label          = "",
    click_function = func,
    function_owner = self,
    position       = { 0, 0.21, 0 },
    height         = 1000,
    width          = 3290,
    scale          = { 1, 1, 1 },
    color          = { 1, 1, 1, 0 },
    font_color     = { 1, 1, 1 },
    hoverColor    = { 1, 1, 1, 0.6 },
    tooltip        = "Confirm Selected Starting Skill"
  })
end


function enableSkillToken(obj, _, _)
  local GUID = obj.getGUID()
  local skill, ownerColor
  for c, skills in pairs(skillButtons) do
    for s, g in pairs(skills) do
      if g == GUID then skill, ownerColor = s, c break end
    end
  end
  if not skill then return end
  for otherSkill, otherGUID in pairs(skillButtons[ownerColor]) do
    if otherSkill ~= "Confirm" and otherSkill ~= "Banner" then
      local otherObj = getObjectFromGUID(otherGUID)
      if otherObj and otherGUID ~= GUID then
        otherObj.setGMNotes("disabled")
        createSkillButton(otherObj, otherSkill, false, ownerColor)
      end
    end
  end
  obj.setGMNotes("enabled")
  createSkillButton(obj, skill, true, ownerColor)
  local confirmObj = getObjectFromGUID(skillButtons[ownerColor]["Confirm"])
  createSkillConfirmButton(confirmObj, ownerColor)
  confirmObj.setPositionSmooth(locs[ownerColor]["confirmSkill"], false, false)
end


function disableSkillToken(obj, _, _)
  local skill, ownerColor
  for c, skills in pairs(skillButtons) do
    for s, g in pairs(skills) do
      if g == obj.getGUID() then skill, ownerColor = s, c break end
    end
  end
  if not skill then return end
  obj.setGMNotes("disabled")
  createSkillButton(obj, skill, false, ownerColor)
end


function confirmSkillToken(_, playerColor, _, color)
  local ownerColor = color or playerColor or "red"
  local enabledSkill = nil
  local skillObjs = getObjectsByTag("btn_skill_selection", ownerColor)
  for _, o in ipairs(skillObjs) do
    if o.getName() ~= "Confirm" and o.getGMNotes():lower() == "enabled" then
      enabledSkill = o.getName():gsub(" Skill Line Token$","")
      break
    end
  end
  local bc = ownerColor:gsub("^%l", string.upper)
  if enabledSkill then
    local skillFound = false
    for _, bagObj in pairs(getObjectbyName("Skills").getObjects()) do
      if bagObj.name:find(enabledSkill) then skillFound = true end
    end
    if not skillFound then
      broadcastToAll("[" .. Color.fromString(bc):toHex() .. "]" .. bc .. " Player[-] selected "..enabledSkill..", but both copies have already been claimed.", "Orange")
      return
    end
    for _, o in ipairs(skillObjs) do o.destruct() end
    broadcastToAll("[" .. Color.fromString(bc):toHex() .. "]" .. bc .. " Player[-] has selected Starting Skill Line: " ..enabledSkill.. ".", "White")
    deploySkillItems(enabledSkill, ownerColor)
    destructClearPlayerareaButton(ownerColor)
  else
    broadcastToAll("Please select a Starting Skill Line button before confirming.", bc)
  end
end


function deploySkillItems(skillName, playerColor)
  local baseDeck  = getObjectbyName("Skills")
  local skillBag  = getObjectbyName("Skill Tokens Bag")
  local skillCard = nil
  for _, deckObj in pairs(baseDeck.getObjects()) do
    if string.find(deckObj.name, skillName) then skillCard = baseDeck.takeObject({ guid = deckObj.guid }) end
  end
  if not skillCard then broadcastToAll("No skill card found for " .. playerColor .. " " .. skillName, "Orange") return end
  skillCard.setRotation({ 0, 180, 0 })  
  local pos = (playerColor == "red" and { -54.97,5.2,-42 }) or (playerColor == "orange" and { -19.29,5.2,-42 }) or (playerColor == "blue" and { 17.07,5.2,-42 }) or { 52.71,5.2,-42 }
  skillCard.setPosition(pos)
  local skillToken = nil
  for _, bagObj in pairs(skillBag.getObjects()) do
    if string.find(bagObj.name, skillName) then
      skillToken = skillBag.takeObject({ guid = bagObj.guid }) break
    end
  end
  if skillToken then
    skillToken.setRotation({ 0, 180, 0 })
    local spos=(playerColor == "red" and { -50.73,1.5,-20.90 }) or (playerColor == "orange" and { -15.09,1.5,-20.90 }) or (playerColor == "blue" and { 21.32,1.5,-20.90 }) or { 56.85,1.5,-20.90 }
    skillToken.setPosition(spos)
  end
  pullSkillDice(skillName, playerColor)
end


function pullSkillDice(skillName, playerColor)
  playerColor = playerColor:gsub("^%l", string.upper)
  if skillName == "Light Armor" or skillName == "Heavy Armor" then
    broadcastToAll("Armor skill selected for Starting Skill Line - choose and pull starting dice manually.", playerColor)
    return
  elseif skillName == "Illusion" then
    broadcastToAll("Line with odd starting dice selected for Starting Skill Line - choose and pull starting dice manually to avoid clashing with other players..", playerColor)
    return
  elseif skillName == "Acrobatics" or skillName == "Legerdemain" or skillName == "Speech" or skillName == "Restoring Light" or skillName == "Daedric Summoning" then
    broadcastToAll("Nonstandard line selected for Starting Skill Line - choose and pull starting dice manually.", playerColor)
    return
  else
    local posDice = (playerColor == "Red" and {{ -49.73, 1.77, -20.40 }, { -49.74, 1.77, -21.40 }}) or (playerColor == "Orange" and {{ -14.08, 1.77, -20.40 }, { -14.09, 1.77, -21.40 }}) or
    (playerColor == "Blue" and {{ 22.33, 1.77, -20.40 }, { 22.32, 1.77, -21.40 }}) or (playerColor == "Green" and {{ 57.87, 1.77, -20.40 }, { 57.85, 1.77, -21.40 }})

    local dieName = (skillName == "Bow" and "Snipe") or (skillName == "Two Handed" and "Wrecking Blow") or
    (skillName == "One Hand And Shield" and "Shield Discipline") or (skillName == "Destruction Staff" and "Force Shock")

    local skillBag = getObjectbyName((skillName == "Bow" and "Bag Skill Line Bow") or (skillName == "Two Handed" and "Bag Skill Line Two Handed") or
    (skillName == "One Hand And Shield" and "Bag Skill Line One Hand And Shield") or (skillName == "Destruction Staff" and "Bag Skill Line Destruction Staff"))

    for i = 1, 2 do
      local die = nil
      for _, object in pairs(skillBag.getObjects()) do
        if object.name:find(dieName) then
          die = skillBag.takeObject({ guid = object.guid })
          break
        end
      end
      Wait.frames(function()
      if die ~= nil then
        die.setPosition(posDice[i])
      end
      end)
    end
  end
end


function destructClearPlayerareaButton(playerColor)
  for _, object in pairs(getObjects()) do
    if object.getName() == "Button Clear Playerarea" and object.getGMNotes() == playerColor then object.destruct() end
  end
end


raceButtons = { red = {}, orange = {}, blue = {}, green = {} }

function initRaceButtons()
  local playerColors = { "red", "orange", "blue", "green"}
  for _, playerColor in ipairs(playerColors) do
    local raceObjs = getObjectsByTag("btn_race_selection", playerColor)
    raceButtons[playerColor] = {}
    for _, obj in ipairs(raceObjs) do
      local race = obj.getName()
      --- there will be a space and then a letter at the end of the string, I need to get rid of them and keep the rest      
      race = race:match("^(.*)%s+%w+$") or race
      raceButtons[playerColor][race] = obj
      local state = obj.getGMNotes()
      if race ~= "Confirm" and not obj.hasTag('banner') then
        if state == "enabled" then
          createRaceButton(obj, race, true, playerColor)
        else
          obj.setGMNotes("disabled")
          createRaceButton(obj, race, false, playerColor)
        end
      end
    end
  end
end


function createRaceButton(obj, race, enabled, playerColor)  
  local hoverColor = buttonHoverColors[playerColor] or { 1, 1, 1, 0 }
  local baseTooltip  = {
      ["Argonian"]   = "Health: 5\nStamina: 3\nMagicka: 2\nCombat: 1\nCooldown: 2\n\n",
      ["Breton"]     = "Health: 5\nStamina: 2\nMagicka: 3\nCombat: 1\nCooldown: 2\n\n",
      ["Dark Elf"]   = "Health: 4\nStamina: 2\nMagicka: 3\nCombat: 2\nCooldown: 2\n\n",
      ["High Elf"]   = "Health: 4\nStamina: 2\nMagicka: 4\nCombat: 1\nCooldown: 2\n\n",
      ["Imperial"]   = "Health: 5\nStamina: 2\nMagicka: 2\nCombat: 2\nCooldown: 2\n\n",
      ["Khajiit"]    = "Health: 4\nStamina: 3\nMagicka: 2\nCombat: 2\nCooldown: 2\n\n",
      ["Nord"]       = "Health: 4\nStamina: 2\nMagicka: 2\nCombat: 3\nCooldown: 2\n\n",
      ["Orc"]        = "Health: 5\nStamina: 2\nMagicka: 2\nCombat: 1\nCooldown: 3\n\n",
      ["Redguard"]   = "Health: 4\nStamina: 3\nMagicka: 2\nCombat: 3\nCooldown: 1\n\n",
      ["Wood Elf"]   = "Health: 5\nStamina: 3\nMagicka: 1\nCombat: 2\nCooldown: 2\n\n",
  }

  local abilityTooltip =  {
      ["Argonian"]      = "Argonian Resistance:\nOnce per battle, when you would be dealt damage, prevent all of that damage.",
      ["Breton"]        = "Opportunist:\nOnce per battle, when you overtax a [Weapon] or [Armor], return that item to your pack, instead of discarding it. You may then move a different item in your pack to a ready slot.",
      ["Dark Elf"]      = "Dynamic:\nOnce per battle, during your turn, recover any 4 skill dice from your cooldown track, replacing each with light fatigue.",
      ["High Elf"]      = "Syrabane's Boon:\nOnce per battle, during your turn, place any adventurer in an unoccupied entrance tile hex and heal them for 3 HP.",
      ["Imperial"]      = "Imperial Mettle:\nOnce per battle, when you would be dealt 3 or fewer damage, prevent that damage and instead gain that much tenacity.",
      ["Khajiit"]       = "Cutpurse:\nOnce per battle, you may automatically succeed at a lockpick check without rolling any dice. Then, move up to 5 hexes.",
      ["Nord"]          = "Reveler:\nOne per battle, when performing an engage in [Light Weapon], [Heavy Weapon], or [Ranged], add 1 enemy Combat die to your engage, plus an additional enemy Combat die for each [Weapon] in your inventory.",
      ["Orc"]           = "Swift Warrior:\nOnce per battle, after the end of your turn, gain 1 overfatigue to take an immediate extra turn.",
      ["Redguard"]      = "Adrenaline Rush:\nOnce per battle, during your turn, remove up to 3 fatigue or status die from your cooldown track, and heal for 1 HP for each die removed. If the total HP recovered exceeds your Health stat, it is gained as bonus HP.",
      ["Wood Elf"]      = "Hunter's Eye:\nOnce per battle, before any unit's turn, apply a Stealth status die to up to 2 party members in play.",
  }

  obj.clearButtons()

  local rot = obj.getRotation()
  local rotButton = { 0, 0, 0 }
  local posButton = { 0, 0.11, 0 }
  if math.floor(rot.z + 0.5) % 360 == 180 then
    posButton = { 0, -0.11, 0 }
    rotButton = { 0, 180, 180 }
  end

  if enabled then
    obj.createButton({
      label          = "",
      click_function = "disableRaceToken",
      function_owner = self,
      position       = posButton,
      rotation       = rotButton,
      height         = 800,
      width          = 800,
      font_size      = 1500,
      scale          = { 1, 1, 1 },
      color          = hoverColor,
      tooltip        = "De-Select Race: " .. race .. "\n\n" .. baseTooltip[race] .. abilityTooltip[race]
    })
    obj.highlightOn((playerColor:gsub("^%l", string.upper)))
  else
    obj.createButton({
      label          = "",
      click_function = "enableRaceToken",
      function_owner = self,
      position       = posButton,
      rotation       = rotButton,
      height         = 800,
      width          = 800,
      font_size      = 1100,
      scale          = { 1, 1, 1 },
      font_color     = { 1, 1, 1 },
      color          = { 0, 0, 0, 0 },
      hoverColor    = hoverColor,
      tooltip        = "Select Race: " .. race .. "\n\n" .. baseTooltip[race] .. abilityTooltip[race]
    })
    obj.highlightOff()
  end
end


function createRaceConfirmButton(obj, color)
  local func = "confirmRaceToken"..color
  if not self.getVar(func) then
    self.setVar(func, function(o, playerColor, altClick) confirmRaceToken(o, playerColor, altClick, color) end)
  end
  obj.clearButtons()
  obj.createButton({
    label          = "",
    click_function = func,
    function_owner = self,
    position       = { 0, 0.21, 0 },
    height         = 1000,
    width          = 3290,
    scale          = { 1, 1, 1 },
    color          = { 1, 1, 1, 0 },
    font_color     = { 1, 1, 1 },
    hoverColor     = { 1, 1, 1, 0.6 },
    tooltip        = "Confirm Selected Race"
  })
end


function enableRaceToken(obj, _, _)
  local race = obj.getName()
  race = race:match("^(.*)%s+%w+$") or race
  local ownerColor
  for _, tag in ipairs(obj.getTags()) do
    local c = tag:match("^player_(%w+)$")
    if c then ownerColor = c break end
  end
  if not ownerColor then return end

  local currentlyEnabled = obj.getGMNotes() == "enabled"

  if currentlyEnabled then
    -- Deselect this button
    obj.setGMNotes("disabled")
    createRaceButton(obj, race, false, ownerColor)
  else
    -- Enable this button and disable all others
    for otherRace, otherObj in pairs(raceButtons[ownerColor]) do
      if otherRace ~= "Confirm" and otherRace ~= "Banner" and otherObj ~= obj then
        otherObj.setGMNotes("disabled")
        createRaceButton(otherObj, otherRace, false, ownerColor)
      end
    end
    obj.setGMNotes("enabled")
    createRaceButton(obj, race, true, ownerColor)
  end

  -- Refresh confirm button
  local confirmObj = nil
  for _, object in pairs(getObjects()) do
    if object.getName() == "Confirm" and object.hasTag('player_' .. ownerColor) and object.hasTag('btn_race_selection') then confirmObj = object end
  end
  if confirmObj then
    createRaceConfirmButton(confirmObj, ownerColor)
    confirmObj.setPositionSmooth(locs[ownerColor]["confirmRace"], false, false)
  end
end


function disableRaceToken(obj, _, _)
  -- Just deselect this one
  local race = obj.getName()
  race = race:match("^(.*)%s+%w+$") or race
  local ownerColor
  for _, tag in ipairs(obj.getTags()) do
    local c = tag:match("^player_(%w+)$")
    if c then ownerColor = c break end
  end
  if not ownerColor then return end

  obj.setGMNotes("disabled")
  createRaceButton(obj, race, false, ownerColor)
end


function confirmRaceToken(_, playerColor, _, color)
  local ownerColor = color or playerColor or "red"
  local enabledRace = nil
  local enabledObj = nil
  local raceObjs = getObjectsByTag("btn_race_selection", ownerColor)

  local raceType = nil
  for _, o in ipairs(raceObjs) do
    if o.getName() == "Banner" then
      raceType = o.getGMNotes()
    end
  end
  if not raceType then raceType = "test" end
  for _, o in ipairs(raceObjs) do
    if o.getName() ~= "Confirm" and o.getGMNotes():lower() == "enabled" then
      enabledRace = o.getName()
      enabledObj = o
      break
    end
  end

  local bc = ownerColor:gsub("^%l", string.upper)
  if enabledRace then
    broadcastToAll("[" .. Color.fromString(bc):toHex() .. "]" .. bc .. " Player[-] selected Race: "..enabledRace:sub(1, -3), "White")

    -- Remove all race buttons
    for _, o in ipairs(raceObjs) do
      if not o.hasTag('player_chip') then
        o.destruct()
      end
    end
    for _, object in pairs(getObjects()) do
      if object.hasTag('banner') and object.hasTag('btn_race_selection') and object.hasTag('player_' .. ownerColor) then
        object.destruct()
      end
    end
    destructClearPlayerareaButton(ownerColor)
    deployRaceItems(enabledObj, ownerColor, raceType)
  else
    broadcastToAll("Please select a Race button before confirming.", bc)
  end
end


function deployRaceItems(buttonObj, playerColor, _)
  if type(buttonObj) ~= "userdata" or not buttonObj.hasTag then
    log("deployRaceItems expected a button object, got something else.", playerColor:gsub("^%l", string.upper))
    return
  end

  local rotButtonObj = buttonObj.getRotation()

  for _, obj in pairs(getObjects()) do
    if obj.hasTag('player_chip') and obj.hasTag('player_' .. playerColor) and obj ~= buttonObj then
      clear_old_chips(obj)
      obj.destruct()
    end
  end

  local colorStr, colorTag, hpToken, hpCounter, board, pegCD, posCD1, posCD3
  if playerColor == "red" then
    colorStr = "Red";    colorTag = "player_red"
    hpToken  = getObjectFromGUID("d8630c"); hpCounter = getObjectFromGUID("12870c")
    board    = getObjectFromGUID("a1c5f4"); pegCD = getObjectFromGUID("1052b3")
    posCD1   = { -59.74, 2.02, -30.85 }; posCD3 = { -58.04, 2.02, -30.84 }
  elseif playerColor == "orange" then
    colorStr = "Orange"; colorTag = "player_orange"
    hpToken  = getObjectFromGUID("566482"); hpCounter = getObjectFromGUID("a6b220")
    board    = getObjectFromGUID("1fe5f3"); pegCD = getObjectFromGUID("c39117")
    posCD1   = { -24.13, 2.05, -30.94 }; posCD3 = { -22.40, 2.05, -30.94 }
  elseif playerColor == "blue" then
    colorStr = "Blue";   colorTag = "player_blue"
    hpToken  = getObjectFromGUID("e1638b"); hpCounter = getObjectFromGUID("68b5c6")
    board    = getObjectFromGUID("7d559d"); pegCD = getObjectFromGUID("108fc1")
    posCD1   = { 12.25, 2.05, -30.94 }; posCD3 = { 13.95, 2.05, -30.93 }
  elseif playerColor == "green" then
    colorStr = "Green";  colorTag = "player_green"
    hpToken  = getObjectFromGUID("c8eee5"); hpCounter = getObjectFromGUID("a8ecfa")
    board    = getObjectFromGUID("e0a25a"); pegCD = getObjectFromGUID("29531e")
    posCD1   = { 47.86, 2.05, -30.89 }; posCD3 = { 49.56, 2.05, -30.88 }
  else
    return
  end

  local posStam = {
    Red         = {{ -60.07,1.54,-21.50 }, { -59.06,1.54,-21.50 }, { -58.06,1.54,-21.50 }},
    Orange      = {{ -24.29,1.54,-21.50 }, { -23.29,1.54,-21.50 }, { -22.29,1.54,-21.50 }},
    Blue        = {{ 12.00,1.54,-21.50 }, { 13.00,1.54,-21.50 }, { 14.00,1.54,-21.50 }},
    Green       = {{ 47.76,1.54,-21.50 }, { 48.77,1.54,-21.50 }, { 49.77,1.54,-21.50 }},
  }
  local posMag = {
    Red        = {{ -60.07,1.54,-20.25 }, { -59.06,1.54,-20.25 }, { -58.06,1.54,-20.25 }, { -57.06,1.54,-20.25 }},
    Orange     = {{ -24.29,1.54,-20.25 }, { -23.29,1.54,-20.25 }, { -22.29,1.54,-20.25 }, { -21.29,1.54,-20.25 }},
    Blue       = {{ 12.00,1.54,-20.25 }, { 13.00,1.54,-20.25 }, { 14.00,1.54,-20.25 }, { 15.00,1.54,-20.25 }},
    Green      = {{ 47.76,1.54,-20.25 }, { 48.77,1.54,-20.25 }, { 49.77,1.54,-20.25 }, { 50.77,1.54,-20.25 }},
  }
  local posCombat = {
    Red           = {{ -55.66,1.67,-20.25 }, { -54.32,1.67,-20.25 }, {-52.97,1.67,-20.25 }},
    Orange        = {{ -19.96,1.67,-20.25 }, { -18.62,1.67,-20.25 }, {-17.26,1.67,-20.25 }},
    Blue          = {{ 16.40,1.67,-20.25 }, { 17.74,1.67,-20.25 }, {19.12,1.67,-20.25 }},
    Green         = {{ 52.03,1.67,-20.25 }, { 53.36,1.67,-20.25 }, {54.73,1.67,-20.25 }},
  }

  local bagStam = getObjectbyName("Stamina Stat Token Bag")
  local bagMag  = getObjectbyName("Magicka Stat Token Bag")

  local tagMap = {
    argonian_a = { val=5, chipTag="argonian_a", stamina=3, magicka=2, combat=1 },
    argonian_b = { val=5, chipTag="argonian_b", stamina=3, magicka=2, combat=1 },
    breton_a   = { val=5, chipTag="breton_a",   stamina=2, magicka=3, combat=1 },
    breton_b   = { val=5, chipTag="breton_b",   stamina=2, magicka=3, combat=1 },
    d_elf_a    = { val=4, chipTag="d_elf_a",    stamina=2, magicka=3, combat=2 },
    d_elf_b    = { val=4, chipTag="d_elf_b",    stamina=2, magicka=3, combat=2 },
    h_elf_a    = { val=4, chipTag="h_elf_a",    stamina=2, magicka=4, combat=1 },
    h_elf_b    = { val=4, chipTag="h_elf_b",    stamina=2, magicka=4, combat=1 },
    imperial_a = { val=5, chipTag="imperial_a", stamina=2, magicka=2, combat=2 },
    imperial_b = { val=5, chipTag="imperial_b", stamina=2, magicka=2, combat=2 },
    khajiit_a  = { val=4, chipTag="khajiit_a",  stamina=3, magicka=2, combat=2 },
    khajiit_b  = { val=4, chipTag="khajiit_b",  stamina=3, magicka=2, combat=2 },
    nord_a     = { val=4, chipTag="nord_a",     stamina=2, magicka=2, combat=3 },
    nord_b     = { val=4, chipTag="nord_b",     stamina=2, magicka=2, combat=3 },
    orc_a      = { val=5, chipTag="orc_a",      stamina=2, magicka=2, combat=1, cd="cd3" },
    orc_b      = { val=5, chipTag="orc_b",      stamina=2, magicka=2, combat=1, cd="cd3" },
    redguard_a = { val=4, chipTag="redguard_a", stamina=3, magicka=2, combat=3, cd="cd1" },
    redguard_b = { val=4, chipTag="redguard_b", stamina=3, magicka=2, combat=3, cd="cd1" },
    w_elf_a    = { val=5, chipTag="w_elf_a",    stamina=3, magicka=1, combat=2 },
    w_elf_b    = { val=5, chipTag="w_elf_b",    stamina=3, magicka=1, combat=2 },
  }

  local chosen = nil
  for tag, stats in pairs(tagMap) do
    if buttonObj.hasTag(tag) then
      chosen = stats
      break
    end
  end
  if not chosen then return end

  local val, chipTag = chosen.val, chosen.chipTag
  local stamina, magicka, combat = chosen.stamina, chosen.magicka, chosen.combat

  local needSetup = not board.hasTag('race_pulled')
  if needSetup then
    if chosen.cd == "cd3" and pegCD then
      pegCD.setPositionSmooth(posCD3)
    elseif chosen.cd == "cd1" and pegCD then
      pegCD.setPositionSmooth(posCD1)
    end
    for i = 1, stamina do
      local statChip = bagStam.takeObject()
      if statChip then statChip.setPositionSmooth(posStam[colorStr][i], false, false) end
    end
    for i = 1, magicka do
      local statChip = bagMag.takeObject()
      if statChip then statChip.setPositionSmooth(posMag[colorStr][i], false, false) end
    end
    local bagCombat = getObjectbyName("Bag Dice Combat")
    for i = 1, combat do
      local die = bagCombat.takeObject()
      Wait.frames(function() die.setPositionSmooth(posCombat[colorStr][i], false, false) end)
    end
    if val == 5 and hpToken then
      hpToken.setState(1)
    end
    if hpCounter then
      hpCounter.call('set_val', val)
    end
    board.addTag('race_pulled')
  end

  -- get button's race tag
  local matchTag = nil
  for _, t in pairs(buttonObj.getTags()) do
    if t:match("_a$") or t:match("_b$") then
      matchTag = t
      break
    end
  end

  log("matchTag: " .. matchTag)

  local raceDeck = getObjectbyName("Races")

  log(raceDeck)

  if raceDeck ~= nil and matchTag then
    for _, deckObj in pairs(raceDeck.getObjects()) do
      if deckObj.tags then
        for _, t in ipairs(deckObj.tags) do
          if t == matchTag then
            local pos = raceDeck.getPosition()
            pos.y = pos.y + .2
            local raceCardBase = raceDeck.takeObject({ guid = deckObj.guid, position = { 0, -10, 0 }, smooth = false })
            Wait.frames(function()
              if not raceCardBase then return end
              local raceCard = raceCardBase.clone()
              if string.find(buttonObj.getName(), " B") or string.find(buttonObj.getName(), " D") then
                raceCard.setRotation({ 0, 180, 180 })
              end
              raceCard.setPosition(
                playerColor    == "red"    and { -63.19, 1.35, -27.90 }
                or playerColor == "orange" and { -27.51, 1.35, -27.95 }
                or playerColor == "blue"   and { 8.85, 1.35, -27.95 }
                or playerColor == "green"  and { 44.49, 1.35, -27.95 }
              )
              raceDeck.putObject(raceCardBase)
            end)
            break
          end
        end
      end
    end
  end

  local baseChip = nil
  local bagBase = getObjectbyName("Player Chip Clone Bag")
  for _, bagObj in pairs(bagBase.getObjects()) do
    if bagObj.tags then
      for _, t in pairs(bagObj.tags) do
        if t == chipTag then
          local pos = bagBase.getPosition(); pos.y = 3.5
          baseChip = bagBase.takeObject({ guid = bagObj.guid, position = pos })
          break
        end
      end
    end
    if baseChip then break end
  end
  Wait.frames(function()
    local cloneChip = baseChip.clone()
    if not baseChip.hasTag('player_red') and not baseChip.hasTag('player_orange') and not baseChip.hasTag('player_blue') and not baseChip.hasTag('player_green') then
      Wait.frames(function() bagBase.putObject(baseChip) end)
    else
      if cloneChip.hasTag('player_red') then cloneChip.removeTag('player_red') end
      if cloneChip.hasTag('player_orange') then cloneChip.removeTag('player_orange') end
      if cloneChip.hasTag('player_blue') then cloneChip.removeTag('player_blue') end
      if cloneChip.hasTag('player_green') then cloneChip.removeTag('player_green') end
    end
    if not cloneChip then return end
    local pos = playerColor == "red" and { -63.19, 2.0, -25.00 } or playerColor == "orange" and { -27.51, 2.0, -25.00 } or playerColor == "blue" and { 8.85, 2.0, -25.00 } or playerColor == "green" and { 44.49, 2.0, -25.00 }
    cloneChip.setRotation(rotButtonObj)
    cloneChip.setPosition(pos)
    Wait.time(function()

      cloneChip.clearButtons()
      cloneChip.addTag(colorTag)
      cloneChip.addTag('player_chip')
      
      if rotButtonObj.z > 135 and rotButtonObj.z < 225 then
        cloneChip.addTag('flipped')
      end
      
      initializePlayerPanel({
        playerChip = cloneChip,
        color      = playerColor,
      })
      
    end, 0.2)
  end, 1)
end




-- ***** CLASS BUTTONS *****

classButtons = { red = {}, orange = {}, blue = {}, green = {} }

function initClassButtons()
  local colors = { "red","orange","blue","green" }
  for _, color in ipairs(colors) do
    local classObjs = getObjectsByTag("btn_class", color)
    classButtons[color] = {}
    for _, obj in ipairs(classObjs) do
      local class = obj.getName()
      classButtons[color][class] = obj.getGUID()
      local state = obj.getGMNotes()
      if class ~= "Confirm" and class ~= "Banner" then
        if state == "enabled" then
          createClassButton(obj, class, true, color)
        else
          obj.setGMNotes("disabled")
          createClassButton(obj, class, false, color)
        end
      end
    end
  end
end


function createClassButton(obj, class, enabled, playerColor)
  local hoverColor = buttonHoverColors[playerColor] or { 1,1,1,0 }
  obj.clearButtons()
  if enabled then
    obj.createButton({
      label          = "",
      click_function = "disableClassToken",
      function_owner = self,
      position       = { 0, 0.21, 0 },
      height         = 1000,
      width          = 3290,
      scale          = { 1, 1, 1 },
      color          = hoverColor,
      tooltip        = "De-Select Class: "..class
    })
    obj.highlightOn((playerColor:gsub("^%l", string.upper)))
  else
    obj.createButton({
      label          = "",
      click_function = "enableClassToken",
      function_owner = self,
      position       = { 0, 0.21, 0 },
      height         = 1000,
      width          = 3290,
      scale          = { 1, 1, 1 },
      color          = { 1, 1, 1, 0 },
      hoverColor     = hoverColor,
      tooltip        = "Select Class: "..class
    })
    obj.highlightOff()
  end
end


function createClassConfirmButton(obj, color)
  local func = "confirmClassToken"..color
  if not self.getVar(func) then
    self.setVar(func, function(o, playerColor, altClick) confirmClassToken(o, playerColor, altClick, color) end)
  end
  obj.clearButtons()
  obj.createButton({
    label          = "",
    click_function = func,
    function_owner = self,
    position       = { 0, 0.21, 0 },
    height         = 1000,
    width          = 3290,
    scale          = { 1, 1, 1 },
    color          = { 1, 1, 1, 0 },
    font_color     = { 1, 1, 1 },
    hoverColor    = { 1, 1, 1, 0.6 },
    tooltip        = "Confirm Selected Class"
  })
end


function enableClassToken(obj, _, _)
  local GUID = obj.getGUID()
  local class, ownerColor
  for c, classes in pairs(classButtons) do
    for s, g in pairs(classes) do
      if g == GUID then class, ownerColor = s, c break end
    end
  end
  if not class then return end
  for otherClass, otherGUID in pairs(classButtons[ownerColor]) do
    if otherClass ~= "Confirm" and otherClass ~= "Banner" then
      local otherObj = getObjectFromGUID(otherGUID)
      if otherObj and otherGUID ~= GUID then
        otherObj.setGMNotes("disabled")
        createClassButton(otherObj, otherClass, false, ownerColor)
      end
    end
  end
  obj.setGMNotes("enabled")
  createClassButton(obj, class, true, ownerColor)
  local confirmObj = nil
  for _, object in pairs(getObjects()) do
    if object.getName() == "Confirm" and object.hasTag('player_' .. ownerColor) and object.hasTag('btn_class') then
      confirmObj = object
      break
    end
  end
  if confirmObj then
    classButtons[ownerColor]["Confirm"] = confirmObj.getGUID()
    createClassConfirmButton(confirmObj, ownerColor)
    confirmObj.setPositionSmooth(locs[ownerColor]["confirmClass"], false, false)
  end
end


function disableClassToken(obj, _, _)
  local class, ownerColor
  for c, classes in pairs(classButtons) do
    for s, g in pairs(classes) do
      if g == obj.getGUID() then class, ownerColor = s, c break end
    end
  end
  if not class then return end
  obj.setGMNotes("disabled")
  createClassButton(obj, class, false, ownerColor)
end


function confirmClassToken(obj, playerColor, altClick, color)
  local ownerColor = color or playerColor or "red"
  local enabledClass = nil
  local classObjs = getObjectsByTag("btn_class", ownerColor)
  for _, o in ipairs(classObjs) do
    if o.getName() ~= "Confirm" and o.getGMNotes():lower()=="enabled" then
      enabledClass = o.getName()
      break
    end
  end
  local bc = ownerColor:gsub("^%l", string.upper)
  if enabledClass then
    local classFound = false
    local bagClass = getObjectbyName("Classes")
    for _, bagObj in pairs(bagClass.getObjects()) do
      if string.find(bagObj.name, enabledClass) then classFound = true end
    end
    if not classFound then
      broadcastToAll("[" .. Color.fromString(bc):toHex() .. "]" .. bc .. " Player[-] selected Class: "..enabledClass..", but it has already been claimed.", bc)
      return
    end
    for _, o in ipairs(classObjs) do o.destruct() end
    broadcastToAll("[" .. Color.fromString(bc):toHex() .. "]" .. bc .. " Player[-] has selected Class: "..enabledClass..".", bc)
    deployClassItems(enabledClass, ownerColor)
    destructClearPlayerareaButton(ownerColor)
  else
    broadcastToAll("Please select a Class button before confirming.", bc)
  end
end


function deployClassItems(enabledClass, color)
  local classDeck = getObjectbyName("Classes")
  local classCardBase = nil
  if classDeck == "nil" then return end
  for _, deckObj in pairs(classDeck.getObjects()) do
    if deckObj.name == enabledClass then
      classCardBase = classDeck.takeObject({ guid = deckObj.guid, position = {0, -10, 0}, smooth = false})
      break
    end
  end
  if classCardBase ~= nil then
    Wait.frames(function()
      local class_card = classCardBase.clone()
      class_card.setPosition(
        color    == "red"    and { -46.68, 1.35, -27.96 }
        or color == "orange" and { -10.99, 1.35, -27.96 }
        or color == "blue"   and { 25.36, 1.35, -27.96 }
        or color == "green"  and { 61.00, 1.35, -27.96 }
      )
      classDeck.putObject(classCardBase)
    end)
  end
end


-- ***** CLEAR PLAYER AREA BUTTONS *****

clearPlayerareaButtons = { red = nil, orange = nil, blue = nil, green = nil }

function initClearPlayerareaButtons()
  local colors = { "red","orange","blue","green" }
  for _, color in ipairs(colors) do
    local objs = getObjectsByTag("btn_clear_playerarea", color)
    if #objs > 0 then
      local obj = objs[1]
      clearPlayerareaButtons[color] = obj.getGUID()
      createClearPlayerareaButton(obj, color)
    end
  end
end

function createClearPlayerareaButton(obj, playerColor)
  local func = "clear_playerarea_"..playerColor
  if not self.getVar(func) then
    self.setVar(func, function(o, clickerColor, altClick)
      clearPlayerareaAction(o, clickerColor, altClick, playerColor)
    end)
  end

  obj.clearButtons()
  obj.createButton({
    label          = "",
    click_function = func,
    function_owner = self,
    position       = { 0, 0.21, 0 },
    height         = 1000,
    width          = 2250,
    scale          = { 1, 1, 1 },
    color          = { 1, 1, 1, 0 },
    font_color     = { 1, 1, 1 },
    hoverColor    = { 1, 1, 1, 0.6 },
    tooltip        = "Completely clear "..(playerColor:gsub("^%l", string.upper)).." Player Area.\n\n WARNING: This process is irreversible, and will require a mod reload if undesireably done accidentally."
  })
end

function clearPlayerareaAction(_, clickerColor, _, ownerColor)
  local bc = ownerColor:gsub("^%l", string.upper)  
  broadcastToAll(Player[clickerColor].steam_name .. " has cleared [" .. Color.fromString(bc):toHex() .. "]" .. bc .. "[-] Player Area.", "White")
  for _, object in pairs(getObjects()) do
    if object.hasTag('player_' .. ownerColor) then object.destruct() end
  end
end