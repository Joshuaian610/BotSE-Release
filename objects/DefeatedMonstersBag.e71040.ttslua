local namePairs = {
    ["Wood Elf Marauder"] = "Wood Elf Bandit",
    ["Wispmother"] = "Wisp",
    ["Spider"] = "Mudcrab",
    ["Skeleton Mage"] = "Skeleton",
    ["Skeever"] = "Skeever Pup",
    ["Redguard Marauder"] = "Redguard Bandit",
    ["Orc Marauder"] = "Orc Bandit",
    ["Nord Marauder"] = "Nord Bandit",
    ["Lurcher"] = "Spriggan",
    ["Khajiit Marauder"] = "Khajiit Bandit",
    ["Imperial Marauder"] = "Imperial Bandit",
    ["High Elf Marauder"] = "High Elf Bandit",
    ["Dark Elf Marauder"] = "Dark Elf Bandit",
    ["Crocodile"] = "Guar",
    ["Breton Marauder"] = "Breton Bandit",
    ["Bear"] = "Wolf",
    ["Argonian Marauder"] = "Argonian Bandit",
    ["Voriplasm"] = "Bog Dog",
    ["Hackwing Swarm"] = "Hackwing",
    ["Will-O-The-Wisp"] = "Imp",
    ["Mountain Lion"] = "Boar",
    ["Riekr"] = "Horker",
    ["Ghost"] = "Zombie",
    ["Kwama Warrior"] = "Scrib",
    ["Cliff Strider"] = "Cliff Racer",
    ["Falmer"] = "Draugr",
    ["Chaurus"] = "Bristleback",
    ["Wood Ord Marauder"] = "Wood Orc Bandit",
    ["Thunderbug"] = "Hoarvor",
    ["Argonian Warlord"] = "Redguard Mercenary",
    ["Breton Archmage"] = "Khajiit Cultist",
    ["Bull Mammoth"] = "Mammoth",
    ["Dremora"] = "Troll",
    ["Flame Atronach"] = "Scamps",
    ["Frost Atronach"] = "Wraith Of Crows",
    ["Giant"] = "Nord Swordmaster",
    ["Haj Mota"] = "Giant Snake",
    ["Goblin Butcher"] = "Goblin Shaman",
    ["Harpy"] = "Giant Bat",
    ["Khajiit Cutthroat"] = "Dark Elf Sentry",
    ["Lamia"] = "Dreugh",
    ["Lich"] = "High Elf Necromancer",
    ["Nord Pyromancer"] = "Orc Wizard",
    ["Storm Atronach"] = "Banekin",
    ["Titan"] = "Ogre",
    ["Wood Elf Deadeye"] = "Imperial Enforcer",
    ["Argonian Behemoth"] = "Argonian Stalker",
    ["Miregaunt"] = "Wamasu",
    ["Worm Anchorite"] = "Worm Warrior",
    ["Minotaur Lord"] = "Minotaur",
    ["Orc Warlord"] = "Breton Usurper",
    ["Bone Colossus"] = "Bonelord",
    ["Nix-Hound Pack"] = "Nix-Hound",
    ["Dark Elf Pillager"] = "Dark Elf Raider",
    ["Vampire"] = "Hagraven",
    ["Briarheart"] = "Reachman",
    ["Wood Elf Stalker"] = "Wood Elf Ranger",
    ["Hollow Guardian"] = "Hollow Predator",
    ["Zirik"] = "Zazita-Do",
    ["Bodean"] = "Xivilai Moath",
    ["Void Centurion Right Arm"] = "Pale Fingers",
    ["Iudex Ovidius"] = "Vampiric Deslandra",
    ["Shadowscale Akisha"] = "Lich Deslandra",
    ["Eveli Sharp Arrow"] = "Razum-Dar",
    ["Void Centurion Left Arm"] = "Paradax Verus",
    ["Morag Tong Assassion"] = "Braig The Bloody",
    ["Wandering Argonian"] = "Mechanist Deslandra",
    ["Big Bad Bazri"] = "Imbued Deslandra",
    ["Watcher"] = "General Deslandra",
    ["Feral Guardian"] = "Diving Cliff Racer",
    ["Enraged Deslandra"] = "Empowered Deslandra",
    ["Dream Weaver Fedryn"] = "Corrupted Creature",
    ["Cursebreaker Deslandra"] = "Xenesthissa",
    ["Clannfear"] = "Atronach",
    ["Ayleid Spirit Hunter"] = "Void Centurion Torso",
    ["Arvan"] = "Chief Dushkul",
    ["Anchorite Deslandra"] = "Kharzug Gra-Magul",
}


local function getCombinedName(name1, name2)
    return name1 .. " / " .. name2
end


local function getNameByRotation(name1, name2, zrot)
    if zrot > 330 or zrot < 30 then
        return name1
    else
        return name2
    end
end


function onObjectLeaveContainer(bag, obj)
    if bag == self and obj.hasTag('enemy_chip') then
        Wait.frames(function()
        obj.setGMNotes("e71040")
        obj.setVar("fresh_out_of_bag", true)
        local rot = obj.getRotation()
        local name = obj.getName()
        for name1, name2 in pairs(namePairs) do
            local combined = getCombinedName(name1, name2)
            if name == name1 or name == name2 or name == combined then
                obj.setName(getNameByRotation(name1, name2, rot.z))
                break
            end
        end
        end)
    end
end


function onObjectEnterContainer(container, enter_object)
    if container ~= self then return end
    local name = enter_object.getName()
    for name1, name2 in pairs(namePairs) do
        if name == name1 or name == name2 then
            local rename_obj = container.takeObject()
            if rename_obj ~= nil then
                Wait.frames(function()
                rename_obj.setName(getCombinedName(name1, name2))
                self.putObject(rename_obj)
                end, 5)
                break
            end
        end
    end
end



function chip_onload(args)
    local saved_data   = args.saved_data
    local chip_obj     = args.chip_obj
    local val          = 0
    chip_obj.setVar('fresh_out_of_bag', false)
    chip_obj.setVar('just_flipped', false)
    if saved_data ~= "" then
        local loaded_data = JSON.decode(saved_data)
        if loaded_data ~= nil then
            chip_obj.setVar('val', loaded_data[1])
            val = loaded_data[1]
        end
    end
    local chip_rotation = chip_obj.getRotation()
    local position, rotation, skill_keywords
    if chip_rotation.z > 330 or chip_rotation.z < 30 then
        skill_keywords = chip_obj.getVar('skill_keywords_0')
        position       = {0.00, 1.00, -1.20}
        rotation       = {250.00, 180.00, 180.00}
    else
        skill_keywords = chip_obj.getVar('skill_keywords_180')
        position       = {0.00, -1.00, -1.20}
        rotation       = {290.00, 0.00, 180.00}
    end
    chip_obj.addContextMenuItem("Player Companion", function(player_color) mark_player_companion(player_color, chip_obj) end)
    chip_obj.addContextMenuItem("Party Companion", function(player_color) mark_party_companion(player_color, chip_obj) end)
    chip_obj.addContextMenuItem("Enemy", function(_) mark_enemy(_, chip_obj) end)
    chip_obj.addContextMenuItem("Set HP 0", function(_) set_hp_0(_, chip_obj) end)
    Wait.time(function()
    if not chip_obj.getVar('fresh_out_of_bag') then
        chip_obj.clearButtons()
        create_counter(position, rotation, chip_obj)
        clear_old_chips(chip_obj)
        update_tile_stack(chip_obj, val)
        update_skill_keywords(chip_obj, skill_keywords)
        update_name(chip_obj)
    end
    end, .5)
end


function mark_player_companion(player_color, object)
    if not (player_color == "Red" or player_color == "Orange" or player_color == "Blue" or player_color == "Green") then return end
    object.clearButtons()
    local player_tag = "player_" .. string.lower(player_color)
    object.addTag(player_tag)
    local position, rotation = get_position_rotation(object)
    getObjectFromGUID("18de0f").call('create_counter_remote', {position=position, rotation=rotation, chip_obj=object})
end

function mark_party_companion(player_color, object)
    for _,tag in ipairs({'player_red','player_orange','player_blue','player_green'}) do
        if object.hasTag(tag) then object.removeTag(tag) end
    end
    object.addTag('party_companion')
    local position, rotation = get_position_rotation(object)
    getObjectFromGUID("18de0f").call('create_counter_remote', {position=position, rotation=rotation, chip_obj=object})
end

function mark_enemy(_, object)    
    object.clearButtons()
    for _,tag in ipairs({'player_red','player_orange','player_blue','player_green','party_companion'}) do
        if object.hasTag(tag) then object.removeTag(tag) end
    end
    local position, rotation = get_position_rotation(object)
    getObjectFromGUID("18de0f").call('create_counter_remote', {position=position, rotation=rotation, chip_obj=object})
end

function set_hp_0(_, object)
    getObjectFromGUID("18de0f").call('set_val_remote', {chip_obj=object, val=0})
end


function get_position_rotation(object)
    local rot = object.getRotation()
    local position, rotation
    if rot.z > 330 or rot.z < 30 then
        position = {0.00, 1.00, -1.20}
        rotation = {250.00, 180.00, 180.00}
    else
        position = {0.00, -1.00, -1.20}
        rotation = {290.00, 0.00, 180.00}
    end
    return position, rotation
end


function update_save(chip_obj, val)
    local data_to_save = {val}
    local saved_data         = JSON.encode(data_to_save)
    chip_obj.script_state  = saved_data
end


function chip_rotate(args)
    local chip_obj = args.chip_obj
    chip_obj.clearButtons()
    clear_old_chips(chip_obj)
    update_save(chip_obj, val)
end


function create_counter_remote(args)
    local position = args.position
    local rotation = args.rotation
    local chip_obj = args.chip_obj
    create_counter(position, rotation, chip_obj)
end


function create_counter(position, rotation, chip_obj)
    local is_color     = false
    if chip_obj.hasTag('player_red') or chip_obj.hasTag('player_orange') or
    chip_obj.hasTag('player_blue') or chip_obj.hasTag('player_green') or chip_obj.hasTag('party_companion') then
        create_color_counter(position, rotation, chip_obj)
        return
    end
    local h_color      = {116/255, 39/255, 26/255, .4}
    local f_color      = {1, 1, 1, 255}
    local val          = chip_obj.getVar('val')
    chip_obj.createButton({
        label          = tostring(val),
        click_function = "add_subtract",
        function_owner = chip_obj,
        position       = position,
        rotation       = rotation,
        height         = 600,
        width          = 400,
        font_size      = 350,
        scale          = {x=1, y=1, z=1},
        font_color     = f_color,
        hover_color    = h_color,
        color          = {116/255, 39/255, 26/255, 255}
    })
    chip_obj.setVar('just_flipped', false)
    chip_obj.setVar('fresh_out_of_bag',false)
    update_save(chip_obj, val)
end


function create_color_counter(position, rotation, chip_obj)
    local val          = chip_obj.getVar('val')
    local color        = nil
    local hover_color  = nil
    if chip_obj.hasTag('player_red') then
        color          = {219/255, 26/255, 24/255, 255}
        hover_color    = {255/255, 77/255, 77/255, 255}
    elseif chip_obj.hasTag('player_orange') then
        color          = {244/255, 100/255, 29/255, 255}
        hover_color    = {255/255, 140/255, 85/255, 255}
    elseif chip_obj.hasTag('player_blue') then
        color          = {31/255, 136/255, 255/255, 255}
        hover_color    = {100/255, 170/255, 255/255, 255}
    elseif chip_obj.hasTag('player_green') then
        color          = {49/255, 179/255, 43/255, 255}
        hover_color    = {110/255, 205/255, 105/255, 255}
    elseif chip_obj.hasTag('party_companion') then
        color          = {33/255, 177/255, 155/255, 255}
        hover_color    = {90/255, 210/255, 190/255, 255}
    end
    chip_obj.createButton({
        label          = tostring(val),
        click_function = "add_subtract",
        function_owner = chip_obj,
        position       = position,
        rotation       = rotation,
        height         = 600,
        width          = 400,
        font_size      = 350,
        scale          = {x=1, y=1, z=1},
        font_color     = "White",
        hover_color    = hover_color,
        color          = color
    })
    chip_obj.setVar('just_flipped', false)
    chip_obj.setVar('fresh_out_of_bag',false)
    update_save(chip_obj, val)
end


function add_subtract(args)
    local chip_obj  = args.chip_obj
    local alt_click = args.alt_click
    local val       = chip_obj.getVar('val')
    local MIN_VALUE = 0
    local MAX_VALUE = 999
    mod = alt_click and -1 or 1
    new_value = math.min(math.max(val + mod, MIN_VALUE), MAX_VALUE)
    if val ~= new_value then
        val = new_value
        chip_obj.setVar('val', val)
        update_val(chip_obj, val)
        update_save(chip_obj, val)
    end
    if val == 0 then
        local bag_obj = getObjectFromGUID(chip_obj.getGMNotes())
        local bag_pos = bag_obj.getPosition()
        bag_pos.y = bag_pos.y + 5
        clear_old_chips(chip_obj)
        chip_obj.setPosition(bag_pos)
        broadcastToAll(chip_obj.getName() .. " has been defeated, and returned to the 'Defeated Monsters' bag!", "White")
        bag_obj.putObject(chip_obj)
    else
        clear_old_chips(chip_obj)
        update_tile_stack(chip_obj, val)
    end
end


function update_val(chip_obj, val)
    chip_obj.editButton({
        index = 0,
        label = tostring(val),
    })
end


function set_val_remote(args)
    local chip_obj = args.chip_obj
    local val      = args.val
    set_val(chip_obj, val)
end


function set_val(chip_obj, value)
    val = value
    update_val(chip_obj, val)
    update_save(chip_obj, val)
    clear_old_chips(chip_obj)
    update_tile_stack(chip_obj, val)
    chip_obj.setVar('val', val)
end


function update_tile_stack_remote(args)
    local chip_obj = args.chip_obj
    local val = args.val
    update_tile_stack(chip_obj, val)
end


function update_tile_stack(chip_obj, val)
    local maxHP = 60
    local redBagGUID = "218b6b"
    local whiteBagGUID = "e1cb0c"
    local chipHeight = 0.1
    local pos = chip_obj.getPosition()
    local val = chip_obj.getVar('val') or val
    if val < 0 then val = 0 end
    if val > maxHP then val = maxHP end
    clear_old_chips(chip_obj)
    local lift_height = .75
    local cast_origin = {pos[1], pos[2] + 0.6, pos[3]}
    local cast_size = {0.9, 1.25, 0.9}
    local hits = Physics.cast({
        origin = cast_origin,
        direction = {0, 1, 0},
        type = 3,
        size = cast_size,
        max_distance = 0,
        debug = false,
    })
    local lifted = {}
    for _, hit in ipairs(hits) do
        if hit.hit_object and hit.hit_object ~= self then
            local obj = hit.hit_object
            local orig_pos = obj.getPosition()
            obj.setPositionSmooth({orig_pos[1], orig_pos[2] + lift_height, orig_pos[3]}, false, true)
            table.insert(lifted, {obj = obj, pos = orig_pos})
        end
    end
    local whiteCount = math.floor(val / 5)
    local redCount = val % 5
    local totalChips = whiteCount + redCount
    local stackHeight = totalChips * chipHeight
    local baseY = pos.y - chipHeight / 2
    local y = baseY
    local spawnedChips = {}
    for i = 1, whiteCount do
        local chip = spawn_chip(whiteBagGUID, {pos[1], y, pos[3]})
        if chip then
            table.insert(spawnedChips, chip)
        end
        y = y + chipHeight
    end
    for i = 1, redCount do
        local chip = spawn_chip(redBagGUID, {pos[1], y, pos[3]})
        if chip then
            table.insert(spawnedChips, chip)
        end
        y = y + chipHeight
    end
    chip_obj.setPosition({pos[1], baseY + stackHeight + chipHeight / 2 + 0.001, pos[3]})
    chip_obj.setLock(true)
    if #spawnedChips == 1 then
        local chip = spawnedChips[1]
        local p = chip.getPosition()
        chip.setPosition({p[1], p[2] - 0.02, p[3]})
    end
    Wait.frames(function()
    if #spawnedChips > 0 then
        local topChip = spawnedChips[#spawnedChips]
        topChip.interactable = false
        if topChip.getName() == "HP Chip" then
            topChip.jointTo(chip_obj, {
                type = "Fixed",
                collision = true,
                break_force = 50000.0,
                break_torque = 50000.0,
            })
        end
        for i = #spawnedChips - 1, 1, -1 do
            local chip = spawnedChips[i]
            local belowChip = spawnedChips[i + 1]
            chip.interactable = false
            belowChip.interactable = false
            if belowChip.getName() == "HP Chip" then
                chip.jointTo(belowChip, {
                    type = "Fixed",
                    collision = true,
                    break_force = 50000.0,
                    break_torque = 50000.0,
                })
            end
        end
    end
    end, 5)
    chip_obj.setLock(false)
end


function update_skill_keywords_remote(args)
    local chip_obj       = args.chip_obj
    local skill_keywords = args.skill_keywords
    update_skill_keywords(chip_obj, skill_keywords)
end


function update_skill_keywords(chip_obj, skill_keywords)
    local skill_descriptions    = {
        ["Aggressive"]          = "After rolling enemy Combat dice, this unit rerolls all misses 1 time before dealing damage to its target.",
        ["Arcane"]              = "The damage dealt by this unit is true damage.",
        ["Bane"]                = "After this unit’s engage, apply a Bane status die to this unit’s target.",
        ["Bide"]                = "If this unit does not move on its turn, it heals for 2 HP at the end of its turn.",
        ["Bladed"]              = "When engaging an adjacent target, this unit deals an additional 2 damage to its target.",
        ["Blind"]               = "After this unit’s engage, apply a Blind status die to this unit’s target.",
        ["Burn"]                = "After this unit determines its target, the target must choose to lose 1 tenacity, discard 1 item, or deal itself 1 true damage.",
        ["Chilblain"]           = "After this unit is engaged by an adventurer who is not using a weapon item that adventurer gains light fatigue equal to player count.",
        ["Colossal"]            = "This unit deploys with additional HP equal to the total number of Combat skill dice trained by adventurers.",
        ["Cornered"]            = "This unit deploys with an additional 2 HP for each undefeated adventurer.",
        ["Daze"]                = "After this unit’s engage, apply a Daze status die to this unit’s target.",
        ["Decay"]               = "At the end of this unit’s turn, it is dealt 1 true damage.",
        ["Detection"]           = "This unit ignores Stealth status dice when targeting.",
        ["Dispel"]              = "After this unit is engaged by an adventurer in magic battle form or by a daedra unit, this unit deals player count true damage to the engaging unit, even if defeated.",
        ["Disrupt"]             = "When this unit determines a target, its target must exhaust 1 die from its active slots.",
        ["Divert"]              = "This unit cannot lose its last HP unless it is already at 1 HP prior to taking damage.",
        ["Dodge"]               = "When this unit is engaged by an opposing unit, prevent damage dealt to this unit equal to the number of rolled skill dice that do not deal damage.",
        ["Elusive"]             = "This unit prevents all damage (including true damage) dealt by units that were not adjacent to it at the start of the current turn.",
        ["Enfeeble 1"]          = "After this unit’s engage, its target gains 1 light fatigue.",
        ["Enfeeble 2"]          = "After this unit’s engage, its target gains 2 light fatigue.",
        ["Enfeeble 3"]          = "After this unit’s engage, its target gains 3 light fatigue.",
        ["Enfeeble 4"]          = "After this unit’s engage, its target gains 4 light fatigue.",
        ["Enfeeble 5"]          = "After this unit’s engage, its target gains 5 light fatigue.",
        ["Enfeeble 6"]          = "After this unit’s engage, its target gains 6 light fatigue.",
        ["Ethereal"]            = "When this unit is dealt damage by an adventurer not in magic battle form, this unit prevents player count damage.",
        ["Instigate"]           = "After this unit is defeated, each adventurer immediately draws a random level 1 enemy and deploys it to the closest unoccupied hex to them.",
        ["Intimidate"]          = "After this unit’s engage, apply a Fear status die to this unit’s target. If the target already has a Fear status die, remove it instead.",
        ["Iron Bark"]           = "When this unit is dealt damage by non-adjacent units, its defense is increased by 1 for that engage.",
        ["Lord"]                = "At the start of this unit’s turn, set aside a level 5 ^ from the enemy bag. If no level 5 V are available, this unit increases its Combat stat by 2 for its engage this turn. At the end of this unit’s turn, deploy the set-aside unit to the closest unoccupied hex.",
        ["Maim"]                = "After this unit’s engage, apply a Maim status die to this unit’s target.",
        ["Motivate"]            = "At the start of this unit’s turn, all adjacent allied units gain 1 tenacity, and all adjacent opposing units lose 1 tenacity.",
        ["Native"]              = "This unit has the skill specific to the current province.",
        ["Necromancy"]          = "At the end of this unit’s turn, deploy the top unit of the defeated stack to the closest unoccupied hex to this unit with player count HP. This new enemy does not take a turn this round.",
        ["Necrotic"]            = "At the end of this unit’s turn, it deals all adjacent units 1 true damage.",
        ["Penumbra"]            = "After this unit is defeated, it replaces the weakest allied non-quest unit and assumes that unit’s HP and status dice. The replaced unit is returned to its enemy bag.",
        ["Rally"]               = "After this unit is defeated, if it is not the last enemy in play, deploy an enemy of the next lowest level to the hex where this unit was defeated. Then, return this unit to its enemy bag.",
        ["Recover"]             = "At the start of this unit’s turn, it heals for player count HP.",
        ["Restrain"]            = "After this unit’s movement, all opposing units within 3 hexes of this unit are moved 1 hex closer to it if possible.",
        ["Retreat"]             = "At the end of this unit’s turn, if no units took damage this turn, this unit gains a Stealth status die and heals for 1 HP.",
        ["Reward"]              = "After this unit defeated, each adventurer chooses and gains 1 of the following:\n• 1 legendary item • 5 tenacity • Advance Health stat by 1, if possible.",
        ["Riposte 1"]           = "Each turn, the first time this unit is dealt damage by an adjacent opposing unit, this unit will then deal 1 damage back, so long as it was not defeated.",
        ["Riposte 2"]           = "Each turn, the first time this unit is dealt damage by an adjacent opposing unit, this unit will then deal 2 damage back, so long as it was not defeated.",
        ["Riposte 3"]           = "Each turn, the first time this unit is dealt damage by an adjacent opposing unit, this unit will then deal 3 damage back, so long as it was not defeated.",
        ["Riposte 4"]           = "Each turn, the first time this unit is dealt damage by an adjacent opposing unit, this unit will then deal 4 damage back, so long as it was not defeated.",
        ["Ritual 1"]            = "At the end of this unit’s turn, all allied units in sight heal for 1.",
        ["Ritual 2"]            = "At the end of this unit’s turn, all allied units in sight heal for 2.",
        ["Ritual 3"]            = "At the end of this unit’s turn, all allied units in sight heal for 3.",
        ["Ritual 4"]            = "At the end of this unit’s turn, all allied units in sight heal for 4.",
        ["Rot"]                 = "After this unit is defeated by an adventurer, that adventurer gains 1 overfatigue.",
        ["Rush"]                = "If this unit cannot target an opposing unit after its movement, it moves a second time instead.",
        ["Shatter"]             = "Each turn, the first time this unit is engaged by an adventurer who is not overtaxing a weapon that adventurer must discard a weapon from a ready slot after the engage.",
        ["Siphon"]              = "At the end of this unit’s turn, remove 1 HP from each non-quest unit within range. Place all HP removed under this unit’s chip (may exceed Health stat).",
        ["Slap"]                = "At the start of this unit's turn, it deals 1 true damage to the strongest adjacent unit. If there are no adjacent units, it does this damage to itself.",
        ["Smite"]               = "If this unit is not targeting all party members on its turn, its Combat stat is doubled.",
        ["Stalwart"]            = "This unit cannot lose more than 1 HP in a single turn.",
        ["Steal"]               = "When this unit determines a target, roll 1 D6. If the result is greater than or equal to its target’s current HP, that target discards a non-food item from a ready slot.",
        ["Subdue"]              = "Before this unit deals damage, its target loses tenacity equal to the amount of damage dealt.",
        ["Swap"]                = "This unit treats occupied hexes as unoccupied. When it moves into an occupied hex, its occupant is placed in the hex this unit moved out of.",
        ["Swift"]               = "This unit’s movement is equal to the current round (Fatigue Rounds = 6).",
        ["True Strike"]         = "If all of this unit’s rolled enemy Combat dice result in a 1, this unit deals true damage.",
        ["Unbridled"]           = "Before this unit deals damage, roll 1 D6. If the result is 3-6, the damage it rolled will be dealt as true damage, and this unit deals 1 additional true damage to each adventurer. If this battle takes place in High Rock, also increase unrest by 1 on a result of 3-6.",
        ["Vindictive"]          = "This unit increases its Combat stat by the number of opposing adventurers.",
        ["Vinesnare"]           = "After this unit’s engage, its target must drain 1 available Combat skill die.",
        ["Vision"]              = "This unit ignores sight restrictions.",
    }
    local native_skill_descriptions = {
        ["Black Marsh"]             = "When this unit determines a target, its target must exhaust a number of dice from its active slots as determined by the current weather. Sunny = 1 Rainy = 2 Flooding = 3.",
        ["Cyrodiil"]                = "When this unit determines a target, its target must exhaust an available skill die. If the Empire Remnant is dominant, the skill die is drained instead.",
        ["Morrowind"]               = "After this unit is engaged by an opposing unit, apply a Blind status die to the opposing unit.",
        ["High Rock"]               = "After this unit is defeated, all allied units heal for HP equal to the current unrest.",
        ["Skyrim"]                  = "When this unit determines a target, its target must move 1 item from a ready slot to their pack. If the party is currently in an under siege town, the target must move all items to their pack.",
        ["Valenwood"]               = "When this unit is dealt damage by non-adjacent units, its defense is increased by 1 for that engage.",
    }
    chip_obj.setDescription("")
    local desc_lines = {}
    local current_province = nil
    local province_map_zone = getObjectFromGUID("64c0a4")
    for _, obj in ipairs(province_map_zone.getObjects()) do
        local name = obj.getName()
        local match = string.match(name, "^(.-) Overland Map$")
        if match then
            current_province = match
            break
        end
    end
    for i, keyword in ipairs(skill_keywords) do
        if keyword ~= "" then
            local text = skill_descriptions[keyword]
            local label = keyword
            if keyword == "Native" and current_province then
                if current_province:find("Skyrim") then current_province = "Skyrim" end
                text = native_skill_descriptions[current_province] or ""
                label = "Native (" .. current_province .. ")"
            end
            if text then
                table.insert(desc_lines, label .. ":\n" .. text)
            end
        end
    end
    if #desc_lines > 0 then
        chip_obj.setDescription(table.concat(desc_lines, "\n\n"))
    end
    update_name(chip_obj)
end

function update_name(chipObj)
    local rot = chipObj.getRotation()
    local updateName = nil
    if rot.z > 330 or rot.z < 30 then
        updateName = chipObj.getVar('str_0')
    else
        updateName = chipObj.getVar('str_180')
    end
    chipObj.setName(updateName)
end


function clear_old_chips_remote(args)
    local chip_obj = args.chip_obj
    clear_old_chips(chip_obj)
end


function clear_old_chips(chip_obj)
    local modelPos = chip_obj.getPosition()
    local hitList = Physics.cast({
        origin       = modelPos,
        direction    = {0, -1, 0},
        type         = 2,
        size         = {0.5, 0.5, 0.5},
        max_distance = 5,
        debug        = false,
    })
    for _, hit in ipairs(hitList) do
        local hitObject = hit.hit_object
        if hitObject and hitObject.getName() == "HP Chip" and hitObject ~= chip_obj then
            hitObject.jointTo()
            hitObject.destruct()
        end
    end
end


function spawn_chip(bagGUID, position)
    local bag = getObjectFromGUID(bagGUID)
    if not bag then
        return
    end
    local chip = bag.takeObject({
        position = position,
        smooth = false,
    })
    return chip
end
